package compose.project.click.click.data.repository

import compose.project.click.click.data.SupabaseConfig
import compose.project.click.click.data.models.*
import io.github.jan.supabase.postgrest.from
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.postgrest.query.Order
import io.github.jan.supabase.realtime.PostgresAction
import io.github.jan.supabase.realtime.channel
import io.github.jan.supabase.realtime.postgresChangeFlow
import io.github.jan.supabase.realtime.decodeRecord
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.datetime.Clock

class ChatRepository {
    private val supabase = SupabaseConfig.client

    // Fetch all chats for a user with details
    suspend fun fetchUserChatsWithDetails(userId: String): List<ChatWithDetails> {
        return try {
            // First get all connections for the user
            val connections = supabase.from("connections")
                .select {
                    filter {
                        or {
                            eq("user1Id", userId)
                            eq("user2Id", userId)
                        }
                    }
                }
                .decodeList<Connection>()

            // For each connection, get chat details
            connections.mapNotNull { connection ->
                try {
                    val chat = supabase.from("chats")
                        .select {
                            filter {
                                eq("id", connection.chatId)
                            }
                        }
                        .decodeSingle<Chat>()

                    // Get the other user
                    val otherUserId = if (connection.user1Id == userId) connection.user2Id else connection.user1Id
                    val otherUser = supabase.from("users")
                        .select {
                            filter {
                                eq("id", otherUserId)
                            }
                        }
                        .decodeSingle<User>()

                    // Get last message
                    val lastMessage = try {
                        supabase.from("messages")
                            .select {
                                filter {
                                    eq("chatId", chat.id)
                                }
                                order("createdAt", order = Order.DESCENDING)
                                limit(1)
                            }
                            .decodeSingleOrNull<Message>()
                    } catch (e: Exception) {
                        null
                    }

                    // Count unread messages
                    val unreadCount = try {
                        supabase.from("messages")
                            .select(Columns.raw("count")) {
                                filter {
                                    eq("chatId", chat.id)
                                    eq("isRead", false)
                                    neq("userId", userId)
                                }
                            }
                            .data
                            .let { 0 } // Simplified count - you'd need to parse the actual count
                    } catch (e: Exception) {
                        0
                    }

                    ChatWithDetails(chat, connection, otherUser, lastMessage, unreadCount)
                } catch (e: Exception) {
                    println("Error fetching chat details: ${e.message}")
                    null
                }
            }
        } catch (e: Exception) {
            println("Error fetching user chats: ${e.message}")
            emptyList()
        }
    }

    // Fetch messages for a specific chat
    suspend fun fetchMessagesForChat(chatId: String): List<Message> {
        return try {
            supabase.from("messages")
                .select {
                    filter {
                        eq("chatId", chatId)
                    }
                    order("createdAt", order = Order.ASCENDING)
                }
                .decodeList<Message>()
        } catch (e: Exception) {
            println("Error fetching messages: ${e.message}")
            emptyList()
        }
    }

    // Send a new message
    suspend fun sendMessage(chatId: String, userId: String, content: String): Message? {
        return try {
            val now = Clock.System.now().toEpochMilliseconds()
            val message = Message(
                id = "", // Will be generated by database
                chatId = chatId,
                userId = userId,
                content = content,
                createdAt = now,
                updatedAt = null,
                isRead = false
            )

            val result = supabase.from("messages")
                .insert(message) {
                    select()
                }
                .decodeSingle<Message>()

            // Update chat's updatedAt timestamp
            supabase.from("chats")
                .update(mapOf("updatedAt" to now)) {
                    filter {
                        eq("id", chatId)
                    }
                }

            result
        } catch (e: Exception) {
            println("Error sending message: ${e.message}")
            null
        }
    }

    // Mark messages as read
    suspend fun markMessagesAsRead(chatId: String, userId: String) {
        try {
            supabase.from("messages")
                .update(mapOf("isRead" to true)) {
                    filter {
                        eq("chatId", chatId)
                        neq("userId", userId)
                        eq("isRead", false)
                    }
                }
        } catch (e: Exception) {
            println("Error marking messages as read: ${e.message}")
        }
    }

    // Subscribe to new messages in a chat using Realtime
    fun subscribeToMessages(chatId: String): Flow<Message> {
        val channel = supabase.channel("messages:$chatId")

        val messageFlow = channel.postgresChangeFlow<PostgresAction>(schema = "public") {
            table = "messages"
            // Filter is set via the DSL, not as a property
        }.map { action ->
            when (action) {
                is PostgresAction.Insert -> action.decodeRecord<Message>()
                is PostgresAction.Update -> action.decodeRecord<Message>()
                else -> null
            }
        }.map { it ?: throw IllegalStateException("Unknown message action") }

        return messageFlow
    }

    // Create a new chat for a connection
    suspend fun createChat(connectionId: String): Chat? {
        return try {
            val now = Clock.System.now().toEpochMilliseconds()
            val chat = Chat(
                id = "", // Will be generated by database
                connectionId = connectionId,
                createdAt = now,
                updatedAt = now
            )

            supabase.from("chats")
                .insert(chat) {
                    select()
                }
                .decodeSingle<Chat>()
        } catch (e: Exception) {
            println("Error creating chat: ${e.message}")
            null
        }
    }

    // Fetch a specific chat by ID
    suspend fun fetchChatById(chatId: String): Chat? {
        return try {
            supabase.from("chats")
                .select {
                    filter {
                        eq("id", chatId)
                    }
                }
                .decodeSingle<Chat>()
        } catch (e: Exception) {
            println("Error fetching chat: ${e.message}")
            null
        }
    }

    // Fetch chat with details by chat ID
    suspend fun fetchChatWithDetails(chatId: String, currentUserId: String): ChatWithDetails? {
        return try {
            val chat = fetchChatById(chatId) ?: return null

            val connection = supabase.from("connections")
                .select {
                    filter {
                        eq("chatId", chatId)
                    }
                }
                .decodeSingle<Connection>()

            val otherUserId = if (connection.user1Id == currentUserId) connection.user2Id else connection.user1Id
            val otherUser = supabase.from("users")
                .select {
                    filter {
                        eq("id", otherUserId)
                    }
                }
                .decodeSingle<User>()

            val lastMessage = try {
                supabase.from("messages")
                    .select {
                        filter {
                            eq("chatId", chat.id)
                        }
                        order("createdAt", order = Order.DESCENDING)
                        limit(1)
                    }
                    .decodeSingleOrNull<Message>()
            } catch (e: Exception) {
                null
            }

            val unreadCount = 0 // Simplified for now

            ChatWithDetails(chat, connection, otherUser, lastMessage, unreadCount)
        } catch (e: Exception) {
            println("Error fetching chat with details: ${e.message}")
            null
        }
    }

    // Get user by ID (utility function)
    suspend fun getUserById(userId: String): User? {
        return try {
            supabase.from("users")
                .select {
                    filter {
                        eq("id", userId)
                    }
                }
                .decodeSingle<User>()
        } catch (e: Exception) {
            println("Error fetching user: ${e.message}")
            null
        }
    }
}

